## Model gene expression data with a generalized linear model
Xulong Wang (xulong.wang@jax.org)

***

```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(ape)
library(amap)
library(ggdendro)
library(VennDiagram)
library(MASS)
library(xtable)
library(ggplot2)
library(ggvis)
library(pheatmap)
library(grid)
```

```{r, message=F, warning=F}
rm(list = ls())
setwd("~/Dropbox/GitHub/Ad")
source("function.R")
load("./data/brain2014.rdt")
dt <- brain.tpm
# load("./data/retina2014.rdt")
# dt <- retina.tpm
```

##### This is the distribution of gene expression values for all genes in all 2014 samples in log2-transformed-TPM unit.
```{r}
dim(dt)
hist(c(as.matrix(dt)), main = "", xlab = "log2(TPM)")
```

##### We kept genes who fit two criterias: 
1. Maximal expression must be bigger than 0.25 quantile of the complete datasets
2. Expression value must be bigger than 0 in at least 1/10 of the samples.
```{r}
cutoff <- quantile(c(as.matrix(dt)), 0.25)  # TPM level
dt <- dt[apply(dt, 1, function(x) max(x) > cutoff), ]
dt <- dt[apply(dt, 1, function(x) sum(x > 0) > round(ncol(dt) / 10)), ]
dim(dt)
```

##### Each gene's expression values were modeled with a generalized linear model (GLM) by 4 predictors: age, group, batch, and age group interaction.
```{r}
age <- factor(gsub("^.*(2m|4m|5m|6m).*", "\\1", colnames(dt)), levels = c("2m", "4m", "5m", "6m"))
group <- factor(gsub("^.*(WT|APP).*", "\\1", colnames(dt)), levels = c("WT", "APP"))
batch <- factor(gsub("^.*(2014|mouse).*", "\\1", colnames(dt)), levels = c("2014", "mouse"))
uid <- paste(age, group, sep = "_")
conditions <- c("2m_WT", "2m_APP", "4m_WT", "4m_APP", "5m_WT", "5m_APP", "6m_WT", "6m_APP")
glm.dt <- as.matrix(dt)
glm.fit <- lapply(1:nrow(glm.dt), function (x) summary(lm(glm.dt[x, ] ~ age + group + batch + age * group)))
names(glm.fit) <- rownames(glm.dt)
colnames(dt)
age
group
batch
```

##### This shows what we get from the GLM, take App for example 
```{r}
glm.fit[["App"]]
```

##### We took off each gene's batch effect as estimated by the GLM from its raw expression value. The batch-corrected expression values were used in the downstream pair-wise comparisons.
```{r}
dt.bc <- dt
for (i in 1:nrow(dt.bc)) 
  dt.bc[i, ] <- dt[i, ] - glm.fit[[i]]$coefficients["batchmouse", "Estimate"] * (as.numeric(batch) - 1)
```

##### R2 and F-test p-value from the GLM define how well each gene's expression across the samples could be predicted from the model's predictors, which are age, group, batch, and age group interaction. Small p-value and big R2 suggest good fit. 
##### We searched age- and app-related genes by two criterias with different levels of stringencies on p-value and R2. The more stringent criteria was applied in this document.
```{r}
r2 <- sapply(glm.fit, function (x) x$r.squared)
fval <- sapply(glm.fit, function (x) x$fstatistic)
pval <- apply(fval, 2, function (x) pf(x[1], x[2], x[3], lower.tail = F))
qval <- p.adjust(pval, method = "fdr")

fit.qr <- glm.fit[qval < 0.05 & r2 > 0.5]
geneId <- names(fit.qr)
length(fit.qr)
```

##### In each gene's GLM return, the "Estimate" column represents each predictor's effect size; the "Pr(>|t|)" column represents the corresponding significance. We constructed a matrix of each gene's estimates on each predictor, and another matrix of the corresponding significance values.
```{r}
fit.qr[["App"]]$coefficients
fit.est <- lapply(fit.qr, function (x) x$coefficients[, "Estimate"])
fit.est <- do.call(rbind, fit.est)
tail(fit.est)
fit.pval <- lapply(fit.qr, function (x) x$coefficients[, "Pr(>|t|)"])
fit.pval <- do.call(rbind, fit.pval)
tail(fit.pval)
```

##### To identify each gene's critical predictors, we binarized the estimate and significance matrices by hard cutoffs. Less stringent cutoffs were applied in a separate analysis. 
```{r}
logit <- apply(fit.pval, 2, function (x) x < 0.05) & apply(fit.est, 2, function (x) abs(x) > 0.2)
tail(logit)
```

##### The APP- and age-related genes were identified as those who passed the cutoff in at least one of the APP- and age-related predictors, respectively. 
```{r}
geneId.age <- geneId[as.logical(rowSums(logit[, grep("age", colnames(fit.pval))]))]
geneId.age
geneId.app <- geneId[as.logical(rowSums(logit[, grep("APP", colnames(fit.pval))]))]
geneId.app
```

##### GO and KEGG enrichment analysis was applied on the APP- and age-related genes
```{r}
gk.app <- myGK(geneId.app)
head(gk.app$BP[, c("Term", "Pvalue")])
head(gk.app$MF[, c("Term", "Pvalue")])
head(gk.app$CC[, c("Term", "Pvalue")])
head(gk.app$KEGG[, c("Term", "Pvalue")])

gk.age <- myGK(geneId.age)
head(gk.age$BP[, c("Term", "Pvalue")])
head(gk.age$MF[, c("Term", "Pvalue")])
head(gk.age$CC[, c("Term", "Pvalue")])
head(gk.age$KEGG[, c("Term", "Pvalue")])
```

##### This gives the overlap between the age- and app-genes.
```{r}
grid.newpage()
draw.pairwise.venn(length(geneId.age), length(geneId.app), length(intersect(geneId.age, geneId.app)), 
                   category = c("Age", "APP"), fill = c("light blue", "pink"))
```
                   
##### To classify the APP-related genes in more detail, we collapsed the binarized matrix gene by gene and grouped genes from the unique collapsed patterns. We will repeat the same procedure for the age-related genes.
```{r}
profile <- logit[geneId.app, grep("APP", colnames(logit))]
# profile <- logit[geneId.age, grep("age", colnames(logit))]
tail(profile)

profile.str <- apply(profile, 1, function (x) paste(x, collapse = "-"))
tail(profile.str)
profile.table <- sort(table(profile.str))
profile.Id <- names(profile.table)
profile.Id
```

##### Genes in each group
```{r}
geneId.profile <- list()
for (idx in profile.Id)
  geneId.profile[[idx]] <- geneId.app[profile.str == idx]
# geneId.profile[[idx]] <- geneId.age[profile.str == idx]
geneId.profile
```

##### A tile plot on the groups with each group's gene numbers
```{r}
tile.dt <- NULL
for (i in 1:length(profile.Id))
  tile.dt <- rbind(tile.dt, as.logical(unlist(strsplit(profile.Id[i], "-"))))
tile.dt <- data.frame(value = c(tile.dt), 
  profile = factor(rep(profile.Id, ncol(tile.dt)), levels = profile.Id),
  group = factor(rep(colnames(profile), each = nrow(tile.dt)), levels = colnames(profile)))

ggplot(tile.dt, aes(x = group, y = profile, fill = value)) + geom_tile(colour = "white") +
  theme_bw() + xlab("") + ylab("") + coord_flip() +
  scale_x_discrete(labels = c("2m:APP", "4m:APP", "5m:APP", "6m:APP")) +
# scale_x_discrete(labels = c("4m:WT", "5m:WT", "6m:WT", "4m:APP", "5m:APP", "6m:APP")) +
  scale_y_discrete(labels = profile.table) +
  scale_fill_manual(values = c("grey80", "firebrick1")) 
``` 

##### We repeated the same procedure to classify age-related genes in different groups.
```{r}
# profile <- logit[geneId.app, grep("APP", colnames(logit))]
profile <- logit[geneId.age, grep("age", colnames(logit))]
tail(profile)

profile.str <- apply(profile, 1, function (x) paste(x, collapse = "-"))
tail(profile.str)
profile.table <- sort(table(profile.str))
profile.Id <- names(profile.table)
profile.Id
```

##### Genes in each group
```{r}
geneId.profile <- list()
for (idx in profile.Id)
# geneId.profile[[idx]] <- geneId.app[profile.str == idx]
  geneId.profile[[idx]] <- geneId.age[profile.str == idx]
geneId.profile
```

##### A tile plot on each group's gene numbers
```{r}
tile.dt <- NULL
for (i in 1:length(profile.Id))
  tile.dt <- rbind(tile.dt, as.logical(unlist(strsplit(profile.Id[i], "-"))))
tile.dt <- data.frame(value = c(tile.dt), 
  profile = factor(rep(profile.Id, ncol(tile.dt)), levels = profile.Id),
  group = factor(rep(colnames(profile), each = nrow(tile.dt)), levels = colnames(profile)))

ggplot(tile.dt, aes(x = group, y = profile, fill = value)) + geom_tile(colour = "white") +
  theme_bw() + xlab("") + ylab("") + coord_flip() +
# scale_x_discrete(labels = c("2m:APP", "4m:APP", "5m:APP", "6m:APP")) +
  scale_x_discrete(labels = c("4m:WT", "5m:WT", "6m:WT", "4m:APP", "5m:APP", "6m:APP")) +
  scale_y_discrete(labels = profile.table) +
  scale_fill_manual(values = c("grey80", "firebrick1")) 
``` 
